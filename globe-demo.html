<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Globe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0118 0%, #1a0f2e 50%, #2d1b4e 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            overflow: hidden;
        }

        .globe-container {
            position: relative;
            width: 800px;
            height: 800px;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #globe-canvas {
            width: 800px;
            height: 800px;
            cursor: grab;
            transition: opacity 0.3s ease;
        }

        #globe-canvas:active {
            cursor: grabbing;
        }

        .drag-hint {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            pointer-events: none;
            animation: fadeInOut 3s ease-in-out infinite;
        }

        .drag-hint.hidden {
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        @keyframes fadeInOut {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.8; }
        }

        /* Responsive design */
        @media (max-width: 1024px) {
            .globe-container {
                width: 90vw;
                height: 90vw;
                max-width: 600px;
                max-height: 600px;
            }
            
            #globe-canvas {
                width: 100%;
                height: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="globe-container">
        <canvas id="globe-canvas"></canvas>
        <div class="drag-hint">Drag to rotate</div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const canvas = document.getElementById('globe-canvas');
            const dragHint = document.querySelector('.drag-hint');
            
            if (!canvas || typeof THREE === 'undefined') {
                console.error('Canvas or Three.js not found');
                return;
            }

            // Scene setup
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
            camera.position.z = 4.5;
            camera.position.y = 0;

            const renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                alpha: true,
                antialias: true
            });
            
            // Set size based on container
            const size = Math.min(window.innerWidth * 0.9, 800);
            renderer.setSize(size, size);
            renderer.setPixelRatio(window.devicePixelRatio);

            // Create main globe sphere
            const geometry = new THREE.SphereGeometry(1.5, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: 0x3d2864,        // Purple base color
                emissive: 0x1a0f2e,     // Dark purple glow
                specular: 0x9b59ff,     // Bright purple highlights
                shininess: 100,
                transparent: true,
                opacity: 0.75
            });
            
            const globe = new THREE.Mesh(geometry, material);
            scene.add(globe);

            // Create wireframe overlay
            const wireframeGeo = new THREE.SphereGeometry(1.52, 32, 32);
            const wireframeMat = new THREE.MeshBasicMaterial({
                color: 0x9b59ff,
                wireframe: true,
                transparent: true,
                opacity: 0.35
            });
            const wireframe = new THREE.Mesh(wireframeGeo, wireframeMat);
            scene.add(wireframe);

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);

            const pointLight1 = new THREE.PointLight(0xb87cff, 2, 100);
            pointLight1.position.set(2, 2, 2);
            scene.add(pointLight1);

            const pointLight2 = new THREE.PointLight(0x59c3ff, 1.5, 100);
            pointLight2.position.set(-2, -1, 2);
            scene.add(pointLight2);

            // Rotation state
            let rotationX = 0;
            let rotationY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            let isDragging = false;
            let previousMouseX = 0;
            let previousMouseY = 0;
            let velocityX = 0;
            let velocityY = 0;

            // Mouse/Touch event handlers
            function onDragStart(e) {
                isDragging = true;
                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                previousMouseX = clientX;
                previousMouseY = clientY;
                velocityX = 0;
                velocityY = 0;
                canvas.style.cursor = 'grabbing';
                
                // Hide hint on first interaction
                if (dragHint) {
                    dragHint.classList.add('hidden');
                }
                
                e.preventDefault();
            }

            function onDragMove(e) {
                if (!isDragging) return;
                
                const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
                const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
                
                const deltaX = clientX - previousMouseX;
                const deltaY = clientY - previousMouseY;
                
                // Update target rotation
                targetRotationY += deltaX * 0.005;
                targetRotationX += deltaY * 0.005;
                
                // Clamp X rotation to prevent flipping
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
                
                // Store velocity for momentum
                velocityX = deltaY * 0.005;
                velocityY = deltaX * 0.005;
                
                previousMouseX = clientX;
                previousMouseY = clientY;
                
                e.preventDefault();
            }

            function onDragEnd() {
                if (!isDragging) return;
                isDragging = false;
                canvas.style.cursor = 'grab';
                
                // Apply momentum
                targetRotationX += velocityX * 10;
                targetRotationY += velocityY * 10;
                
                // Clamp X rotation
                targetRotationX = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, targetRotationX));
            }

            // Add event listeners
            canvas.addEventListener('mousedown', onDragStart);
            document.addEventListener('mousemove', onDragMove);
            document.addEventListener('mouseup', onDragEnd);
            
            canvas.addEventListener('touchstart', onDragStart, { passive: false });
            document.addEventListener('touchmove', onDragMove, { passive: false });
            document.addEventListener('touchend', onDragEnd);

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Smooth interpolation
                rotationX += (targetRotationX - rotationX) * 0.1;
                rotationY += (targetRotationY - rotationY) * 0.1;
                
                // Apply friction when not dragging
                if (!isDragging) {
                    velocityX *= 0.95;
                    velocityY *= 0.95;
                }
                
                // Apply rotation to globe
                globe.rotation.x = rotationX;
                globe.rotation.y = rotationY;
                
                // Wireframe rotates slightly differently for depth effect
                wireframe.rotation.x = rotationX * 0.95;
                wireframe.rotation.y = rotationY * 0.95;
                
                // Render scene
                renderer.render(scene, camera);
            }
            
            animate();

            // Handle window resize
            window.addEventListener('resize', () => {
                const newSize = Math.min(window.innerWidth * 0.9, 800);
                renderer.setSize(newSize, newSize);
            });
        });
    </script>
</body>
</html>
